<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="resources/my.css" />
<link rel="stylesheet" href="resources/reveal/css/reveal.css" />
<link rel="stylesheet" href="resources/reveal/css/theme/black.css" />
<link rel="stylesheet" href="resources/reveal/lib/css/zenburn.css" />
<link rel="stylesheet" href="resources/my.css" /></head>
<body><div class="reveal"><div class="slides"><section><table><tr><td width="33%"></td><td><div fgcolor="#ff0000"><b>    𝕃 anguage <br />
    𝔸 bstraction for <br />
     ⟦𝕍⟧ erifiable <br />
    𝔹  lockchain <br />
    𝔻  ecentralized <br />
    𝔸 pplications</b></div></td><td width="33%"></td></tr></table><p> </p><p>François-René Rideau, <em>Alacris</em></p><div align="center">fare@alacris.io</div><p> </p><p>IOHK Summit, 2019-04-11</p><a href="https://alacris.io/"><tt>https://alacris.io/</tt></a></section><section><section><h1>Introduction: Challenges for Secure DApps</h1></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Why No DApps? a Vicious Circle</h1><p> </p><table class="noborder" id="noborder"><tr><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No apps</td><td style="text-align: center; border: none;"></td></tr><tr><td style="text-align: right; border: none;">⬈</td><td style="text-align: center; border: none;"></td><td style="text-align: left; border: none;">⬊</td></tr><tr><td style="text-align: center; border: none;">No tech</td><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No users</td></tr><tr><td style="text-align: right; border: none;">⬉</td><td style="text-align: center; border: none;"></td><td style="text-align: left; border: none;">⬋</td></tr><tr><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No money</td><td style="text-align: center; border: none;"></td></tr></table><p> </p><span class="fragment" data-fragment-index="1">Typical bootstrapping issue!</span></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>What Missing Tech?</h1><p> </p><p>Scalability</p><p>Interoperability</p><p>Portability</p><p>Usability</p><p> </p><span class="fragment" data-fragment-index="1"><h6>Security</h6></span><!----></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Why is Blockchain Security so Hard?</h1><div align="left">Transactions: high-stake, irreversible.</div><p>The &quot;bug budget&quot; is <em>zero</em>.</p><!--Aerospace or biomedical industries--><p> </p><div align="left">Code is fragile.</div><p>Usual languages, tools &amp; methodologies <em>don't even try</em>.</p><!--Parity Wallet: 400 lines, one bug, 280 M$ disappeared!--><p> </p><div align="left">The Internet is hostile.</div><p>Each dollar controlled by a DApp is <em>a bounty to the bad guys</em>.</p></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>The Solution: Logic</h1><div align="left">Dijkstra's approach: use math, prove everything correct.</div><div align="left"><em>You</em> may eschew math automation—the bad guys won't.</div><p> </p><div align="left">You can't retrofit math in existing code.</div><div align="left">You must build around math from the start.</div><p> </p><div align="left">Complexity quickly makes math intractable.</div><div align="left">Adopt Radical Simplicity—in math terms.</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Alacris: Our Take Home Points</h1><p> </p><div align="left">Building secure DApps is extremely hard,</div><div align="left">a DSL makes it tractable.</div><p> </p><div align="left">Automatic Cascading Verification of correctness,</div><div align="left">from DSL down to bit-bashing, composing full abstractions.</div><p> </p><div align="left">Blockchain-Agnostic Model: Consensus-as-Court</div><div align="left">Portab-, Interoperab-, Scalab- ility—through <em>Logic</em>.</div></section></section><section><section><h1>A Domain Specific Language (DSL) for DApps</h1></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a Library?</h1><div align="left">A Library: can <em>do</em> everything, but not <em>prevent</em> much.</div><div align="left">Manually respect its unenforced global invariants… or else.</div><div align="left">Leaks complexity, makes verification harder.</div><p> </p><div align="left">A DSL: can express both positive and negative.</div><div align="left">Global invariants automatically enforced.</div><div align="left">Seals complexity. Makes verification easier.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a new General Purpose Language?</h1><div align="left">General Purpose Language: Library-generator.</div><div align="left">Leaks complexity exponentially until untractable.</div><div align="left">Problem: mushed many levels of abstraction into one.</div><p> </p><div align="left">Proper DSLs: keep small problem spaces.</div><div align="left">Seal complexity at each level of abstraction.</div><div align="left">General-Purpose Logic Meta-Language: factor in multiple layers.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a Contract Language?</h1><div align="left">A DApp is much more than a smart contract:</div><div align="left">Also code running on clients, servers, etc.</div><div align="left">Any bug and poof money gone. Any discrepancy is a bug.</div><p> </p><div align="left">DSL: a single spec for the entire DApp.</div><div align="left">End-Point Projection: Extract all code for each and every component.</div><div align="left">Do it correctly. Do it consistently across components.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not a least share VM with Contracts?</h1><div align="left">Contract VM is for deterministic consensual computations</div><div align="left">optimized for cost-conscious execution</div><div align="left">… computation cost &gt; 10⁶x than for cloud computing.</div><p> </p><div align="left">DApp VM is for asynchronous multiparty computations</div><div align="left">Optimized for Auditability of Game-Theoretic Correctness</div><div align="left">… most computations are on private cloud computers</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>What is in the DSL then?</h1><div align="left">Functional Programming.</div><div align="left">Asynchronous Communication.</div><div align="left">Cryptographic Primitives.</div><div align="left">Modal Logic: Epistemic + Temporal.</div><div align="left">Linear Logic: Resource Management.</div><div align="left">Game Theory: Economic Equilibrium.</div><div align="left">Refinement Logic: Work at many abstraction levels.</div><div align="left">Extension: Finitary Fragment for zk-SNARKs.</div></section></section><section><section><h1>Automatic Cascading Verification</h1></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Semantic Tower</h1><div align="left">Verify entire semantic tower, from user spec to bit bashing.</div><div align="left">Address each issue at proper level of abstraction.</div><p> </p><div align="left">Zoom in and out, at runtime.</div><div align="left">Full Abstraction: no semantic leak.</div><p> </p><div align="left">Average user get automatic theorem proofs with Z3.</div><div align="left">System extenders prove extensions correct in Coq.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Correctness Properties to Automatically Verify</h1><div align="left">User-defined protocol invariants.</div><p> </p><div align="left">Linear Resources, Access Control, Time Bounds.</div><p> </p><div align="left">Game-Theoretic Liveness: progress if all actors honest.</div><p> </p><div align="left">Game-Theoretic Safety: no loss to bad actors.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Verification techniques</h1><div align="left">Type Theory: manual with Coq for system extenders.</div><div align="left">Theorem Proving: automated with Z3 for users.</div><div align="left">Model Checking: domain-specific models.</div><div align="left">Strand Spaces: model attacker capabilities.</div><div align="left">Dynamical System Simulation: test attack scenarios.</div><div align="left">Composable Implementation Layers: keep complexity in check.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Composable implementation layers</h1><div align="left">Category Theory: Computations as categories.</div><div align="left">States as nodes (&quot;objects&quot;), transitions as arrows (&quot;morphisms&quot;).</div><div align="left">Implementations as partial functors (profunctors).</div><div align="left">Game-Theoretic Safety &amp; Liveness as composable properties.</div><div align="left">Code Instrumentations as natural transformations.</div><p> </p><div align="left">Good sign: functoriality implies full abstraction!</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Less Formal Methods</h1><div align="left">Lightweight methods: Quickly check simple properties.</div><div align="left">Starve attackers of low-hanging fruits.</div><p> </p><div align="left">Keep track of axioms at every level of abstraction.</div><div align="left">Can't do without axioms. Make them explicit, review them.</div><p> </p><div align="left">Human Processes matter.</div><div align="left">Design. Review. Discipline. Red team.</div></section></section><section><section><h1>Blockchain-Agnostic Model: Consensus-as-Court</h1></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Consensus-as-Court</h1><div align="left">Analogy: common abstraction, different parameters</div><p> </p><div align="left">Conflict avoidance and resolution system.</div><div align="left">Avoidance: Fast. Good guy pays all the time.</div><div align="left">Resolution: Slow. Bad guy pays in unhappy case.</div><p> </p><div align="left">Machines: verification games with fast cheap rigid logic.</div><div align="left">Humans: legal arguments with slow scarce flexible rhetoric.</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Logic for Smart Contracts</h1><div align="left">Arbitrary logical formula for smart contract clause.</div><div align="left">NB: Requires a logic model for blockchains or side-chains.</div><p> </p><div align="left"><em>Game Semantics</em>: translate formulas to verification games.</div><div align="left"><em>Fundamental Theorem</em>: Good guy has winning strategy.</div><p> </p><div align="left">Bad guy loses, then pays damages and court fees.</div><div align="left">With any challengeable claim, deposit collateral as bond.</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Mutual Knowledge</h1><div align="left">Winning Strategy: Not just &quot;there exists&quot; but &quot;I know&quot;</div><p> </p><div align="left">All evidence must be Mutual Knowledge (MK).</div><p> </p><div align="left">Scale with general purpose MK validator network.</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Extension: Zero-Knowledge Proofs</h1><div align="left">Interactive but private validation.</div><div align="left">Anyone can see who's right, about what stays private.</div><p> </p><div align="left">Non-interactive a priori validation.</div><div align="left">Trade-off: good guy pays all the time, a lot.</div><p> </p><div align="left">Interoperability: commitment with different hash functions</div><div align="left">Gambling: Homomorphic encryption of card game hands</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>DSL: Abstract over Backend</h1><div align="left">This blockchain vs That blockchain</div><p> </p><div align="left">Non-Interactive enforcement vs Interactive verification</div><p> </p><div align="left">Public computation vs Private computation</div><p> </p><div align="left">Slow and trustless vs Fast with semi-trusted middleman</div><p> </p><p>No One-size-fits-all backend. Yes One-size-fits-all DApp.</p></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Blockchain-Agnostic Model</h1><div align="left">Portability</div><div align="left">Interoperability</div><div align="left">Scalability</div><div align="left">Usability</div><div align="left"><b>Security</b></div><p> </p><div align="left">Mathematical essence of the Blockchain</div></section></section><section><section><h1>Conclusion</h1></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>The Take Home Points (redux)</h1><p> </p><div align="left">Building secure DApps is extremely hard,</div><div align="left">a DSL makes it tractable.</div><p> </p><div align="left">Automatic Cascading Verification of correctness,</div><div align="left">from DSL down to bit-bashing, composing full abstractions.</div><p> </p><div align="left">Blockchain-Agnostic Model: Consensus-as-Court</div><div align="left">brings portability, interoperability, scalability.</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>The Meta-Story</h1><div align="left">Go to the mathematical essence of things.</div><div align="left">Itself the essence of category theory.</div><div align="left">Identify what the domain is and isn't.</div><p> </p><div align="left">Strip all incidental complexity.</div><div align="left">Embrace multiple levels of abstraction.</div><div align="left">Reconcile Semantics and Reflection.</div><!--In the words of Dick Gabriel:
The programming language paradigm vs the systems paradigm.--></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Contact</h1><p> </p><div align="left">I NEED MORE INFO!   Our website <a href="https://alacris.io/"><tt>https://alacris.io/</tt></a></div><p> </p><div align="left">I WANT TO FOLLOW ALONG!   Medium <a href="https://medium.com/alacris"><tt>https://medium.com/alacris</tt></a></div><p> </p><div align="left">I WANT TO HELP!   Telegram <a href="https://t.me/alacrisio"><tt>https://t.me/alacrisio</tt></a></div><p> </p><div align="left">SHOW ME THE CODE!   <a href="https://github.com/AlacrisIO"><tt>https://github.com/AlacrisIO</tt></a></div></section></section></div></div>
<script src="resources/reveal/lib/js/head.min.js"></script>
<script src="resources/reveal/js/reveal.min.js"></script>
<script>
//<![CDATA[
Reveal.initialize({
  dependencies: [
    {src: "resources/reveal/plugin/highlight/highlight.js",
     async: true, callback: () => hljs.initHighlightingOnLoad()}],
  controls: false})
//]]>
</script></body></html>