<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="resources/my.css" />
<link rel="stylesheet" href="resources/reveal/css/reveal.css" />
<link rel="stylesheet" href="resources/reveal/css/theme/black.css" />
<link rel="stylesheet" href="resources/reveal/lib/css/zenburn.css" />
<link rel="stylesheet" href="resources/my.css" /></head>
<body><div class="reveal"><div class="slides"><section><table><tr><td width="33%"></td><td><div fgcolor="#ff0000"><b>    𝕃 anguage <br />
    𝔸 bstraction for <br />
     ⟦𝕍⟧ erifiable <br />
    𝔹  lockchain <br />
    𝔻  ecentralized <br />
    𝔸 pplications</b></div></td><td width="33%"></td></tr></table> <p>François-René Rideau, <em>Alacris</em></p><div align="center">fare@alacris.io</div> <p>Alacris Tech Talk 2019-04-11 / IOHK Summit, 2019-04-18</p><a href="https://alacrisio.github.io/lavbda/"><tt>https://alacrisio.github.io/lavbda/</tt></a></section><section><section><h1>Introduction: Challenges for Secure DApps</h1></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Why No DApps? a Vicious Circle</h1> <table class="noborder" id="noborder"><tr><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No apps</td><td style="text-align: center; border: none;"></td></tr><tr><td style="text-align: right; border: none;">⬈</td><td style="text-align: center; border: none;"></td><td style="text-align: left; border: none;">⬊</td></tr><tr><td style="text-align: center; border: none;">No tech</td><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No users</td></tr><tr><td style="text-align: right; border: none;">⬉</td><td style="text-align: center; border: none;"></td><td style="text-align: left; border: none;">⬋</td></tr><tr><td style="text-align: center; border: none;"></td><td style="text-align: center; border: none;">No money</td><td style="text-align: center; border: none;"></td></tr></table> <span class="fragment" data-fragment-index="1">Typical bootstrapping issue!</span></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>What Missing Tech?</h1> <p>Scalability</p><p>Interoperability</p><p>Portability</p><p>Usability</p> <span class="fragment" data-fragment-index="1"><h6>Security</h6></span><!----></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Why is Blockchain Security so Hard?</h1><div align="left">Transactions: high-stake, irreversible.</div><div align="left">          The &quot;bug budget&quot; is <em>zero</em>.</div><!--Aerospace or biomedical industries--> <div align="left">Code is fragile.</div><div align="left">          Usual languages, tools &amp; methodologies <em>don't even try</em>.</div><!--Parity Wallet: 400 lines, one bug, 280 M$ disappeared!--> <div align="left">The Internet is hostile.</div><div align="left">          Each dollar controlled by a DApp is <em>a bounty to the bad guys</em>.</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>The Solution: Logic</h1><div align="left">Dijkstra's approach: prove all code correct with math.</div><div align="left">          <em>You</em> may eschew math automation—the bad guys won't.</div> <div align="left">You can't retrofit math in existing code.</div><div align="left">          You must build around math from the start.</div> <div align="left">Complexity quickly makes math intractable.</div><div align="left">          Adopt Radical Simplicity—in math terms.</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction: Challenges for Secure DApps</b></font></p><h1>Alacris: Our Take Home Points</h1> <div align="left">Building secure DApps is extremely hard,</div><div align="left">          a Domain Specific Language (DSL) makes it tractable.</div> <div align="left">Automatic Cascading Verification of correctness,</div><div align="left">          from DSL down to bit-bashing, composing full abstractions.</div> <div align="left">Blockchain-Agnostic Model: Consensus-as-Court</div><div align="left">          Port-, Interoper-, Scal- ability—through <em>Logic</em>.</div></section></section><section><section><h1>A Domain Specific Language (DSL) for DApps</h1></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a Library?</h1><div align="left">A Library: can <em>do</em> everything, but not <em>prevent</em> much.</div><div align="left">          Manually respect its unenforced global invariants… or else.</div><div align="left">          Leaks complexity, makes verification harder.</div> <div align="left">A DSL: can express both positive and negative.</div><div align="left">          Global invariants automatically enforced.</div><div align="left">          Seals complexity, makes verification easier.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a new General Purpose Language?</h1><div align="left">General Purpose Language: Library-generator.</div><div align="left">          Mushes all abstraction levels into one.</div><div align="left">          Leaks complexity exponentially until untractable.</div> <div align="left">Proper DSLs: keep small problem spaces.</div><div align="left">          Seal complexity at each level of abstraction.</div><div align="left">          General-Purpose Logic Meta-Language: factor in multiple layers.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not just a Contract Language?</h1><div align="left">A DApp is much more than a smart contract:</div><div align="left">          Also code running on clients, servers, etc.</div><div align="left">          Any bug and poof money gone. Any discrepancy is a bug.</div> <div align="left">DSL: a single spec for the entire DApp.</div><div align="left">          End-Point Projection: extract code for all components.</div><div align="left">          Do it correctly—consistently across components.</div></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>Why not a least share VM with Contracts?</h1><div align="left">Contract VM is for deterministic consensual computations.</div><div align="left">          Computations cost &gt; 10⁶ more than on cloud.</div><div align="left">          Optimize programs for cost.</div> <div align="left">DApp VM is for asynchronous multiparty computations.</div><div align="left">          Most computations on private cloud.</div><div align="left">          Optimize programs for auditability.</div><!--XXXX Cut...
Consensus: everything computed is public
All: Keys are private information
Poker: hands are private information--></section><section><p align="right" valign="top"><font size="4"><b>A Domain Specific Language (DSL) for DApps</b></font></p><h1>What features in the DApp DSL then?</h1><div align="left">Functional Programming.</div><div align="left">Asynchronous Communication.</div><div align="left">Cryptographic Primitives.</div><div align="left">Modal Logic: Epistemic + Temporal.</div><div align="left">Linear Logic: Resource Management.</div><div align="left">Game Theory: Economic Equilibrium.</div><div align="left">Refinement Logic: Work at many abstraction levels.</div><div align="left">Finitary Logic: zk-proofs (optional)</div></section></section><section><section><h1>Automatic Cascading Verification</h1></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Semantic Tower</h1><div align="left">Verify entire semantic tower, from user spec to bit bashing.</div><div align="left">          Full Abstraction: no semantic leak.</div> <div align="left">Address each issue at proper level of abstraction.</div><div align="left">          Zoom in and out—at runtime.</div> <div align="left">Regular developers <em>automatically</em> get proofs with Z3.</div><div align="left">System extenders <em>manually</em> prove correctness with Coq.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Correctness Properties to Automatically Verify</h1><div align="left">User-defined protocol invariants.</div> <div align="left">Linear Resources, Access Control, Time Bounds.</div> <div align="left">Game-Theoretic Liveness: progress if all actors honest.</div> <div align="left">Game-Theoretic Safety: no loss to bad actors.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Verification techniques</h1><div align="left"><em>Type Theory</em>: grow system with Coq.</div><div align="left"><em>Theorem Proving</em>: user automation with Z3.</div><div align="left"><em>Model Checking</em>: domain-specific models.</div><div align="left"><em>Strand Spaces</em>: model attacker capabilities.</div><div align="left"><em>Dynamical System Simulation</em>: test attack scenarios.</div><div align="left"><em>Composable Implementation Layers</em>: keep complexity in check.</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Composable implementation layers</h1><div align="left">Category Theory: Computations as categories.</div><div align="left">          States as nodes (&quot;objects&quot;), transitions as arrows (&quot;morphisms&quot;).</div> <div align="left">Implementations as partial functors (profunctors).</div><div align="left">          Game-Theoretic Safety &amp; Liveness as composable properties.</div><div align="left">          Code Instrumentations as natural transformations.</div> <div align="left">Good sign: functoriality implies full abstraction!</div></section><section><p align="right" valign="top"><font size="4"><b>Automatic Cascading Verification</b></font></p><h1>Less Formal Methods</h1><div align="left">Lightweight Formal methods: Quickly check simple properties.</div><div align="left">          Starve attackers of low-hanging fruits.</div> <div align="left">Can't do without axioms. Can make them explicit, audit them.</div><div align="left">          Automatically track axioms at every abstraction level.</div> <div align="left">Human Processes matter.</div><div align="left">          Design. Review. Discipline. Check lists. Red team.</div></section></section><section><section><h1>Blockchain-Agnostic Model: Consensus-as-Court</h1></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Consensus-as-Court</h1><div align="left">Analogy: common abstraction, different parameters.</div><div align="left">          Conflict avoidance &amp; resolution. Machines <em>vs</em> humans.</div> <div align="left">Avoidance: Good guy pays, all the time. Reliably Slow.</div><div align="left">Resolution: Bad guy pays, in unhappy case only. Faster/Slower.</div> <div align="left">Machines: verification games with logic—fast cheap rigid.</div><div align="left">Humans: legal arguments with rhetoric—slow expensive flexible.</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Logic for Smart Contracts</h1><div align="left">Smart contract clause is <em>arbitrary logical formula</em>.</div><div align="left">          NB: Requires logic model of the blockchain or side-chain.</div> <div align="left"><em>Game Semantics</em>: translate formulas to verification games.</div><div align="left"><em>Fundamental Theorem</em>: Good guy has winning strategy.</div> <div align="left">Bad guy loses, then pays damages and court fees...</div><div align="left">          out of <em>bond</em>—with any claim, deposit collateral.</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Mutual Knowledge</h1><div align="left">Winning Strategy: &quot;there exists&quot; not enough—&quot;I know&quot; needed.</div><div align="left">          All evidence must be <em>Mutual Knowledge</em> (MK).</div> <div align="left">Consensus. State channels. Plasma. Side-chains?</div><div align="left">MK easier to achieve than <em>Common Knowledge</em>.</div> <div align="left">Scale with general purpose MK validator network.</div><div align="left">          Mutual Knowledge Base (MKB), </div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Extension: Zero-Knowledge Proofs</h1><div align="left"><em>Private</em> interactive validation.</div><div align="left">          Anyone can see who's right, no one knows about what.</div> <div align="left"><em>Non-interactive</em> a priori validation.</div><div align="left">          Trade-off: good guy pays all the time, a lot.</div> <div align="left"><em>Interoperability</em>: commitment with different hash functions</div> <div align="left"><em>Gambling</em>: Homomorphic encryption of card game hands</div></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>DSL: Abstract over Backend</h1><table class="noborder" id="noborder"><tr><td style="text-align: right; border: none;">This blockchain</td><td style="text-align: center; border: none;"><em>vs</em></td><td style="text-align: left; border: none;">That blockchain</td></tr><tr><td style="text-align: right; border: none;">Non-interactive enforcement</td><td style="text-align: center; border: none;"><em>vs</em></td><td style="text-align: left; border: none;">Interactive verification</td></tr><tr><td style="text-align: right; border: none;">Public computation</td><td style="text-align: center; border: none;"><em>vs</em></td><td style="text-align: left; border: none;">Private computation</td></tr><tr><td style="text-align: right; border: none;">Slow and trustless</td><td style="text-align: center; border: none;"><em>vs</em></td><td style="text-align: left; border: none;">Fast semi-trusted middleman</td></tr></table> <div align="left">          Different sets of users have different needs from backends.</div><div align="left">          Different blockchains offer different capabilities to backends.</div><!--No One-size-fits-all backend. Yes One-size-fits-all DApp.--></section><section><p align="right" valign="top"><font size="4"><b>Blockchain-Agnostic Model: Consensus-as-Court</b></font></p><h1>Blockchain-Agnostic Model</h1><div align="left">Portability</div><div align="left">Interoperability</div><div align="left">Scalability</div><div align="left">Usability</div><div align="left"><b>Security</b></div> <div align="left">          Mathematical essence of the Blockchain</div></section></section><section><section><h1>Conclusion</h1></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Alacris: Our Take Home Points (redux)</h1> <div align="left">Building secure DApps is extremely hard,</div><div align="left">          a Domain Specific Language (DSL) makes it tractable.</div> <div align="left">Automatic Cascading Verification of correctness,</div><div align="left">          from DSL down to bit-bashing, composing full abstractions.</div> <div align="left">Blockchain-Agnostic Model: Consensus-as-Court</div><div align="left">          Port-, Interoper-, Scal- ability—through <em>Logic</em>.</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>The Meta-Story</h1><div align="left">Go to the mathematical essence of things.</div><div align="left">          Itself the essence of category theory.</div> <div align="left">Strip all incidental complexity.</div><div align="left">          Identify what the domain is and isn't.</div> <div align="left">Embrace multiple levels of abstraction.</div><div align="left">          Reconcile Semantics and Reflection.</div><!--In the words of Dick Gabriel:
The programming language paradigm vs the systems paradigm.--></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Contact</h1> <div align="left">I NEED MORE INFO!   Our website <a href="https://alacris.io/"><tt>https://alacris.io/</tt></a></div> <div align="left">I WANT TO FOLLOW ALONG!   Medium <a href="https://medium.com/alacris"><tt>https://medium.com/alacris</tt></a></div> <div align="left">I WANT TO HELP!   Telegram <a href="https://t.me/alacrisio"><tt>https://t.me/alacrisio</tt></a></div> <div align="left">SHOW ME THE CODE!   <a href="https://github.com/AlacrisIO"><tt>https://github.com/AlacrisIO</tt></a></div></section></section></div></div>
<script src="resources/reveal/lib/js/head.min.js"></script>
<script src="resources/reveal/js/reveal.min.js"></script>
<script>
//<![CDATA[
Reveal.initialize({
  dependencies: [
    {src: "resources/reveal/plugin/highlight/highlight.js",
     async: true, callback: () => hljs.initHighlightingOnLoad()}],
  controls: false})
//]]>
</script></body></html>